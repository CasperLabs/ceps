#+STARTUP: inlineimages

* Finality Signatures For Secure Joining Node Synchronization
:PROPERTIES:
:CUSTOM_ID: finality-signatures-for-secure-joining-node-synchronization
:END:

** Summary
:PROPERTIES:
:CUSTOM_ID: summary
:END:

CEP PR: [[https://github.com/casperlabs/ceps/pull/0026][casperlabs/ceps#0026]]

Nodes joining the network will use /finality signatures/ to securely
synchronize with the validators.  As a node synchronizes, it will get
signatures of block hashes via the gossip network until it has greater
than threshold =t%= (default: 33%) of the validator weight. Once a node
has enough signatures, it can trust that block hash.  It can then
proceed to download the next block hash.

This is a follow up to [[https://github.com/casperlabs/ceps/pull/0024][casperlabs/ceps#0024]]

** Motivation
:PROPERTIES:
:CUSTOM_ID: motivation
:END:

Nodes joining the network need to get blocks from the block-chain in a
secure manner.  If a block hash has /finality signatures/ from enough
validators then a node can trust it. This is because the security model for
Highway is tolerant of a threshold =t%= (default: 33%) of validators being
Byzantine.  If a node can see that greater than =t%= of the validator
weight has signed a block-hash or is Byzantine, then that node can
trust that block hash.  It suffices for nodes to get these signatures
from the gossip network.

** Guide-level explanation
:PROPERTIES:
:CUSTOM_ID: guide-level-explanation
:END:

Nodes joining the chain need to get /finality signatures/ so it can
trust a block-hash. These come from the gossip network. The security
model dictates they need more than =t%= (default: 33%) of the validator
weight to establish trust.

This is done by asking the gossip network for a block-hash at height
=n=. There are two responses to consider:

  1. There is no block at height =n=
  2. A block hash is provided along with signatures

The diagram below provides the logic for handling these responses.

#+BEGIN_SRC svgbob :file images/0025/state-logic.svg :exports results

                 _____
                /     \
               < Start >
                \_____/
                   |
                   |                  Set n = n + 1
                   |      +-------------------------------------+
                   |      |                                     |
                   |      |                                     |
                   |      |                                     |
                   v      v                                     |
        +----------o------o-----+                               |
        |                       |                               |
   +--->o  Get Signatures/Hash  o<----------------+             |
   |    |  For Block Height n   |                 |             |
   |    |                       |                 |             |
   |    +----------+------------+                 |             |  
   |               |                              | No          |
   |               |                              |             |
   |               v                              |             |
   |    +----------o------------+       +---------+--------+    |
   |    |                       |       |                  |    |
   |    |  Peers Report Block   |       |      Enough      |    |
   |    |    at that Height?    +------>o    Signatures?   |    |
   |    |                       |  Yes  |                  |    |
   |    +----------+------------+       +---------+--------+    |
   |               |                              |             |
   |               | No                           | Yes         |
   |               v                              v             |
   |    +----------o------------+       +---------o--------+    |
   |    |                       |       |                  |    |
   |    |  Last Block Near      |       |    Get Block     |    |
   +----+  Current Timestamp?   |       |    Using Hash    |    |
   | No |                       |       |                  |    |
   |    +----------+------------+       +---------o--------+    |
   |               |                              |             |
   |               | Yes                          |             |
   |               v                              |             |
   |       +-------o-------+                      +-------------+
   |       |               |
   |       |  Era Started  |
   +-------+  Recently?    |
     No    |               |
           +-------+-------+
                   |
                   | Yes
                   v
           ,~~~~~~~o~~~~~~~.
           :               :
           :   Switch to   :
           :   Highway     :
           :   Consensus   :
           :               :
           `~~~~~~~~~~~~~~~'


#+END_SRC

#+RESULTS:
[[file:images/0025/state-logic.svg]]

** Reference-level explanation
:PROPERTIES:
:CUSTOM_ID: reference-level-explanation
:END:

The central place where program logic will change is in
[[https://github.com/xcthulhu/casper-node/blob/0a7f9e5fd7608e2f6574c1e213bd9f5e35880af5/node/src/components/linear_chain_sync.rs#L365-L368][linear_chain_sync::LinearChainSync::fetch_next_block]].

#+BEGIN_SRC rust
  State::SyncingDescendants { .. } => {
      let next_height = block_header.height() + 1;
      fetch_block_at_height(effect_builder, peer, next_height)
  }
#+END_SRC

Before the call to =fetch_block_by_hash=, the =LinearChainSync= process
will need to have acquired a enough weight in signatures as discussed
in [[Guide-level explanation][Guide-level explanation]].

Here =fetch_block_at_height= will yield the block header /and/ the
finality signatures. Moreover, updating =next_height= to
=block_header.height() + 1= will happen only after enough weight of
finality signatures has been observed.

Byzantine nodes are a key concern for calculating the weight.

Nodes must deal with a faulty validator when syncing.  A validator
could make finality signatures with the same height (according to the
block header) and different block hashes.  An approach to deal with
this is as follows. First, introduce an enum:

#+begin_src rust
enum FaultyOrFetchedFinalitySignature {
  Faulty,
  Correct(FinalitySignature)
}
#+end_src

The naming convention in this enum follow [[https://github.com/goral09/casper-node-1/blob/0bbefb1c284784f0307661cdc7c33584ffded3ce/node/src/components/consensus/highway_core/state/panorama.rs#L24-L31][panorama::Observation]].

Then extend [[https://github.com/xcthulhu/casper-node/blob/0a7f9e5fd7608e2f6574c1e213bd9f5e35880af5/node/src/components/linear_chain_sync.rs#L85-L93][linear_chain_sync::State::SyncingDescendants]] with a field
=validator_finality_signatures= with type =BTreeMap<PublicKey,
FaultyOrFetched>=. Fetching validator signatures will update this map.
New signatures are either added or change old signatures to faulty if
detected.

To determine the weight of a block hash in this structure: add the
weight of non-faulty signatures with that hash /plus/ the weight of the
faulty validators. This principle was briefly discussed in the
[[#motivation][Motivation]] section. If this is greater than =t%= (default: 33%) of the
validator weight, then it must be that one of the validator nodes is
not faulty.  This is a /pigeon hole/ argument based on the trust model
for highway.

** Unresolved questions
:PROPERTIES:
:CUSTOM_ID: unresolved-questions
:END:

- Where is the enum that needs to be extended so that the gossip
  protocol to support =fetch_finality_signatures_at_height=?
